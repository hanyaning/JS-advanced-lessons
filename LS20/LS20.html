<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
<script>
        /*
        /正则表达式的文本部分/正则表达式的标识符
        [xyz]指匹配中括号中任意的字符
        标识符：g:全局的检索,获取所有的匹配项还是只获取第一个
        i:是否忽略大小写
    */
    var reg1 = /[bcf]at/gi;
    // var reg1 = new RegExp(/[bcf]at/,'gi');
    // var reg1 = new RegExp("[bcf]at","gi");
    var str = 'fat cat bat Fat ojiidd lppqw';
    var arr =str.match(reg1);
    console.log(arr);


    var reg1 = /adf/gi;
    var str = 'abcdef adf kil';
    str.match(reg1);
    //*表示匹配的次数
    var reg2 = /adf*/gi;
    console.log(str.match(reg2));
    //.表示任意的单个的字符
    var reg3 = /a.c/gi;
    console.log(str.match(reg3));
    // /\d/可以匹配任意的阿拉伯数字【0-9】
    var reg4 = /a\dc/gi;
    var reg4_2 = /a\Dc/gi;
    var str = 'a2c a3c abc';
    str.match(reg4);
    str.match(reg4_2);
    // /\D/表示不是阿拉伯数字
    // /\w/表示任意字母表中的字符，包括下划线
    // /\W/表示不是这些字符
    

    /*
        [xyz]从中括号中的字符集合中任意取一个字符
        [^xyz]排除括号字符集合中的字符
    */
    var str = 'atf btf ctf';
    var reg = /[^abc]tf/gi;
    str.match(reg); 

    //开头为a,后边为阿拉伯数字
    /*
        ^匹配开始的位置
    */
    var reg1= /^a[0-9]/gi;
    var str1 = 'a1 b2 c3 a4';
    str1.match(reg1);

    //$匹配结尾的位置，以数字开头，以z结尾
    var reg2 = /[0-9]z$/gi;
    var str2 = 'abcd9z';
    var str2_2 = 'bcfbdfdfd9';
    str2.match(reg2);
    str2_2.match(reg2);
    reg2.test(str2);
    //如果结果匹配上，则为true,否则为false;

    /*数量词：
        ？表示之前的字符出现0次或者1次s
    */
    var reg1 = /abc?/gi;
    var str1 = 'abc ab kk';
    str1.replace(reg1,"x");
    //+表示的为之前的字符出现一次或者是多次
    var reg2 = /abc+/gi;
    var str2 = "abc abccc abccccc ab";
    str2.replace(reg2,"x");
    //限定{}相邻字母出现的次数，x{m,n}m为出现的最少次数，n为出现的最多次数
    var reg3 = /abc{1,3}/gi;
    var str3 = 'abc abcc abccc abccccc';
    str3.replace(reg3,"x");


    var reg1 = /[bef]at/gi;
    var reg2 = new RegExp("[bef]at",'gi');
    var reg3 = new RegExp(/[bcf]at/,"gi");


    var str1 = 'fat Fat bat cat jdkfdj llo';
    console.log(str1.match(reg1));



        /*
        \s表示数字，.表示任意一个字符
        \w表示[A-Za-Z0-9]
    */
    var reg = /\d/gi;


    /*
        ^a以特定的字符开始
        b$以特定的字符结束
    */
    var reg = /[xyz]a/gi;
    var str1 = 'xabjiya';
    str1.replace(reg,'m');


    /*
        量词：a*表示字符出现0次 多次
        a+字符出现1次 多次
        a？字符出现0次 1次
    */


    //exec匹配相应的字符，返回一个数组,将要匹配的字符也调入进来，分组看作为当前正则的子规则
    //var reg1 = /(abc)\d/gi;
    var reg1 = /(abc)(\def)\d/gi;
    //var str = "abc1efg2";
    var str = 'ab31ef12';
    var result = reg1.exec(str);
    console.log(result);  
    /*
        (2) ["abc1", "abc", index: 0, input: "abc1efg2", groups: undefined]
        0: "abc1"
        1: "abc"
        groups: undefined
        index: 0
        input: "abc1efg2"
        length: 2
        __proto__: Array(0)
    */


    //\n表示从左向右数，引用第几个分组,如果结构较为复杂时，利用引用，n为数字
    var reg1 = /(ss)a\1/gi;
    //var reg1 = /(\d)a(\d)/gi;   这样的字符组合目前不可以替换
    console.log(reg1);
    var str = "ssassj1";
    var result = str.replace(reg1,'x');
    console.log(result);



    //区分是字符串还是正则表达式上的方法
    /*
        String.prototype
        str.replace(正则表达式,"替换的内容")
        str.match()  返回的为数组
        str.search(正则表达式)  得到的为一个索引，出现时的位置，在字符踹中首次出现的位置，如果没有则返回的为-1
    */
   var reg = /(ss)abc\d/gi;
   var str = 'kkafd ssabc2';
   str.match(reg);


   /*
        test("检测的字符串") 验证字符串是否符合正则表达式规则
        exec("检测的字符串")  返回的为数组【匹配的字符串，正则要匹配的字符串】
   */

    //验证压缩文件格式
    /*
        (.+)这样使用最好，压缩文件的名字
        \.表示转义，不表示任意的字符，只是表示.
        (|||)从后缀名中任意取一个
        $表示以结尾，以前面的分组结尾
    */
    var reg = /(.*)\.(rar|zip|7zip|tgz)$/;



    var reg = /^#[a-fA-F0-9]{6}$/;
    /*
        ^#表示的是以#开头
        [a-fA-F0-9]从其中选取任意一个字符
        {6}表示之前的字符出现6次
        $以前面的这些字符结尾
    */
</script>
</html>