<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
<script>
    // ES6为字符串添加了遍历器接口，使得字符串可以被for...of循环遍历
    for (let codePoint of 'foo') {
        console.log(codePoint)
    }
    // "f"
    // "o"
    // "o"

    for (let key in 'foo') {
        console.log(key);
    }

    //提供新的方法用于查找、判断和生成字符串
    var s = 'Hello world!';
    s.startsWith('Hello'); // true
    s.endsWith('!'); // true
    s.includes('o'); // true

    //第二个参数，表示开始搜索的位置
    var s = 'Hello world!';
    s.startsWith('world', 6); // true
    s.endsWith('Hello', 5); // true
    s.includes('Hello', 6); // false

    //repeat方法返回一个新字符串，表示将原字符串重复n次。
    'x'.repeat(3); // "xxx"
    'hello'.repeat(2); // "hellohello"
    'na'.repeat(0); // ""
    //参数如果是小数，会被取整。
    'na'.repeat(2.9); // "nana"
    //如果repeat的参数是负数或者Infinity，会报错。
    'na'.repeat(Infinity);
    // RangeError
    'na'.repeat(-1);
    // RangeError





    //在ES5中，RegExp构造函数的参数有两种情况。
    //第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。
    var regex = new RegExp('xyz', 'i');
    // 等价于
    var regex = /xyz/i;
    //第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。
    var regex = new RegExp(/xyz/i);
    // 等价于
    var regex = /xyz/i;
    //但是，ES5不允许此时使用第二个参数，添加修饰符，否则会报错。
    var regex = new RegExp(/xyz/, 'i');
    // Uncaught TypeError: Cannot supply flags when constructing one RegExp from another

    //ES6改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。
    // 而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。
    new RegExp(/abc/ig, 'i').flags// "i"



    //ES6在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。
    //Number.isFinite();//用来检查一个数值是否为有限的（finite）。
    Number.isFinite(15); // true
    Number.isFinite(0.8); // true
    Number.isFinite(NaN); // false
    Number.isFinite(Infinity); // false
    Number.isFinite(-Infinity); // false
    Number.isFinite('foo'); // false
    Number.isFinite('15'); // false
    Number.isFinite(true); // false

    //Number.isNaN()//用来检查一个值是否为NaN。
    Number.isNaN(NaN); // true
    Number.isNaN(15); // false
    Number.isNaN('15'); // false
    Number.isNaN(true); // false
    Number.isNaN(9/NaN); // true
    Number.isNaN('true'/0); // true
    Number.isNaN('true'/'true') // true
    //ES5通过下面的代码，部署Number.isNaN()
    



    //它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，
    // 而这两个新方法只对数值有效，非数值一律返回false。
    isFinite(25); // true
    isFinite("25"); // true
    Number.isFinite(25); // true
    Number.isFinite("25"); // false
    isNaN(NaN); // true
    isNaN("NaN"); // true
    Number.isNaN(NaN); // true
    Number.isNaN("NaN"); // false

    //6.3 Number.parseInt(), Number.parseFloat()
    //ES6将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。
    // ES5的写法
    parseInt('12.34'); // 12
    parseFloat('123.45#'); // 123.45
    // ES6的写法
    Number.parseInt('12.34'); // 12
    Number.parseFloat('123.45#'); // 123.45

    //这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。
    Number.parseInt === parseInt // true
    Number.parseFloat === parseFloat // true

    //Number.isInteger()
    //Number.isInteger()用来判断一个值是否为整数。
    // 需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。
    Number.isInteger(25); // true
    Number.isInteger(25.0); // true
    Number.isInteger(25.1); // false
    Number.isInteger("15"); // false
    Number.isInteger(true); // false

    ///////Math的扩展
    //Math.trunc方法用于去除一个数的小数部分，返回整数部分。
    Math.trunc(4.1); // 4
    Math.trunc(4.9); // 4
    Math.trunc(-4.1); // -4
    Math.trunc(-4.9); // -4
    Math.trunc(-0.1234); // -0

    //Math.sign方法用来判断一个数到底是正数、负数、还是零
    Math.sign(-5); // -1
    Math.sign(5); // +1
    Math.sign(0); // +0
    Math.sign(-0); // -0
    Math.sign(NaN); // NaN
    Math.sign('foo'); // NaN
    Math.sign(); // NaN


</script>
</html>